#include <Eigen.h>
#include <iostream>

#ifdef __cplusplus
extern "C" {
#endif

static Eigen::Matrix2f m(2,2);
static float a_data[] = {1, 2};
static Eigen::Map<Eigen::Vector2f> va(a_data);

void function1() {
  m << 1, 2, 3, 4;
}
int main()
{    
  function1();
  std::cout << m << std::endl;

  // Eigen::Vector2f vec, ub, lb;
  // vec << -3, 3;
  // ub << 1, 2;
  // lb << -2, -1;
  // vec = vec.cwiseMin(ub).cwiseMax(lb); 
  // std::cout << vec << std::endl;

  
  // Eigen::Vector2f va = Eigen::Map<Eigen::Vector2f>(a);
  // a[0] = -2; a[1] = -10;
  // std::cout << va << std::endl;
  // std::cout << va.data() << " vs " << a << std::endl;

  // Eigen::Vector2f va;
  // va.data() = a;
  // std::cout << va << std::endl;
  // std::cout << va.data() << " vs " << a << std::endl;

  // Eigen::Vector2f va;
  
  a_data[0] = -2; a_data[1] = -10;
  std::cout << va << std::endl;
  std::cout << va.data() << " vs " << a_data << std::endl;
}

#ifdef __cplusplus
}
#endif


/*
Option 1:
// traj_pos_fig8.h (generated by Julia)
X_ref_data[NSTATES*NSIM] = {...}

// main.cpp
VectorNf Xref[NHORIZON]
How to create an array of matrix without allocating new memory. I want Xref[k].data()
to point to X_ref_data.

I know how to do it with one Matrix: 
`static Eigen::Map<Eigen::Vector2f> Xref1(X_ref_data);`
---------
Option 2:
// traj_pos_fig8.h (generated by Julia)
VectorNf XrefAll[NSIM];
XrefAll[0] << ...;
XrefAll[1] << ...;
.
.
.
XrefAll[NSIM-1] << ...;

// main.cpp
data.Xref = &XrefAll[k];

*/