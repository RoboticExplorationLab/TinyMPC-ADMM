#include <Eigen.h>
#include <iostream>

#ifdef __cplusplus
extern "C" {
#endif

static Eigen::Matrix2f m(2,2);
static Eigen::Matrix2f* pm = &m;

struct struct1 {
  Eigen::Matrix2f* m1;
  Eigen::Matrix2f* m2;
} st1 {.m1 = &m};

static float a_data[] = {1, 2};
static Eigen::Map<Eigen::Vector2f> va(a_data);

void initialize() {
  m << 1, 2, 3, 4;
  // pm = &m;
  st1.m1 = pm;
}

static Eigen::Matrix4f foo = (Eigen::Matrix4f() << 
100.000000f,0.000000f,0.000000f,0.000000f,
0.000000f,100.000000f,0.000000f,0.000000f,
0.000000f,0.000000f,100.000000f,0.000000f,
0.000000f,0.000000f,0.000000f,100.000000f).finished();

static Eigen::Vector2f vs[2] = 
{(Eigen::Vector2f() << 1.0f,0.1f).finished(),
(Eigen::Vector2f() << 100.0f,0.0f).finished()};

int main()
{    
  initialize();
  std::cout << m << std::endl;
  std::cout << *pm << std::endl;
  std::cout << foo << std::endl;
  std::cout << *(st1.m1) << std::endl;
  std::cout << (st1.m2) << std::endl;
  std::cout << "vs[0] = \n" << vs[0] << std::endl;
  std::cout << "vs[1] = \n" << vs[1] << std::endl;
  // Eigen::Vector2f vec, ub, lb;
  // vec << -3, 3;
  // ub << 1, 2;
  // lb << -2, -1;
  // vec = vec.cwiseMin(ub).cwiseMax(lb); 
  // std::cout << vec << std::endl;

  
  // Eigen::Vector2f va = Eigen::Map<Eigen::Vector2f>(a);
  // a[0] = -2; a[1] = -10;
  // std::cout << va << std::endl;
  // std::cout << va.data() << " vs " << a << std::endl;

  // Eigen::Vector2f va;
  // va.data() = a;
  // std::cout << va << std::endl;
  // std::cout << va.data() << " vs " << a << std::endl;

  // Eigen::Vector2f va;
  
  a_data[0] = -2; a_data[1] = -10;
  std::cout << va << std::endl;
  std::cout << va.data() << " vs " << a_data << std::endl;
}

#ifdef __cplusplus
}
#endif


/*
Option 1:
// traj_pos_fig8.h (generated by Julia)
X_ref_data[NSTATES*NSIM] = {...}

// main.cpp
VectorNf Xref[NHORIZON]
How to create an array of matrix without allocating new memory. I want Xref[k].data()
to point to X_ref_data.

I know how to do it with one Matrix: 
`static Eigen::Map<Eigen::Vector2f> Xref1(X_ref_data);`
---------
Option 2:
// traj_pos_fig8.h (generated by Julia)
VectorNf XrefAll[NSIM];
XrefAll[0] << ...;
XrefAll[1] << ...;
.
.
.
XrefAll[NSIM-1] << ...;

// main.cpp
data.Xref = &XrefAll[k];
soln.Kinf << ...;
*/